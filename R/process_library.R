#' Extracting representative scans for each feature (ID) and create a new library
#'
#' The function picks a single MS1 and MS2 scan for each ID in the spectral library according to the highest TIC. To generate consensus spectra, all mass spectra of the same ID at the same MS level are aligned (on m/z) and intensities are averaged
#'
#' @param library A list generated by the function library_generator() or the name of mgf spectral library file
#' @param consensus  Logical. TRUE if consensus spectrum is generated by spectral alignment. FALSE if users only wish to keep the spectrum with the highest TIC.ATTENTION: consensus spectra can be generated only if mass spectra are normalized !
#' @param ppm_window  m/z tolerance window (in ppm) for spectra alignment
#' @param strict Logical. TRUE if only keep mass peaks present in all spectra of an ID
#' @param output_library Name of the output library, the file extension must be mgf
#'
#' @return The same as library_generator()
#'
#' @author Youzhong Liu, \email{Youzhong.Liu@uantwerpen.be}
#'
#' @examples
#'
#' # Withholding the scan (MS1 and MS) with highest TIC for each ID:
#'
#' library2_1=process_library(library2, consensus=F, output_library="library_V2_filtered.mgf")
#'
#' # Generating consensus spectra for all scans (MS1 and MS) of the same ID. The scan with highest TIC is used for metadata:
#'
#' library2_2=process_library(library2, consensus=T, ppm_window = 20, output_library="library_V2_consensus.mgf")
#'
#' @export
#'
#' @importFrom MSnbase fData readMgfData
#' @importFrom tools file_ext
#' @importFrom utils write.table

process_library<-function(library, consensus = T, ppm_window = 10, strict = F, output_library=""){

  options(stringsAsFactors = FALSE)
  options(warn=-1)

  #################
  ### Check inputs:
  #################

  if (missing(library)){
    stop("Please provide the output of library_generator() or a .mgf file as input library!")}

  if (is.character(library)){
    if (file_ext(library)!="mgf"){
      stop("The file extension of your input library must be mgf!")
    }}

  if (is.list(library)){
    if (length(library)!=2 || (!is.list(library$sp)) || !is.data.frame(library$metadata)){
      stop("Please make sure your input library is a valid output of library_generator()!")
    }}

  #####################################
  ### Reading from spectral library:
  #####################################

  if (is.character(library)){ # If input is a mgf file
    library=readMgfData(library, verbose = FALSE)
    metadata=fData(library)
    spectrum_list=Mgf2Splist(library)
  } else { # If input is the output of library_generator
    metadata = library$metadata
    spectrum_list = library$sp}

  ##############################################
  ###  Only take IDs where MS2 data is present:
  ##############################################

  index2=which(metadata$MSLEVEL=="2")
  metadata2 = metadata[index2,]
  ID_list=unique(metadata2$ID) # We only take IDs where MS2 data is present
  N = length(ID_list) # Number of items

  new_spectrum_list = list()
  new_meta_data = c()
  NN = 0

  #######################
  ### Consensus MS1 scan:
  #######################

  index1=which(metadata$MSLEVEL==1)
  if (length(index1)>0){
    metadata1=metadata[index1,]
    ID_list=unique(metadata1$ID)
    for (ID in ID_list){
      selected_rows = which(metadata1$ID==ID)
      tics = metadata$TIC[selected_rows]
      wm = which.max(tics)
      max_scan = index1[selected_rows[wm]] # Representative scan in the old library with the highest TIC

      new_meta_data = rbind.data.frame(new_meta_data,metadata[max_scan,]) # Update metadata
      NN = NN+1
      # Append spectra list if no need for spectra merge
      if (!consensus || length(selected_rows)==1){
        new_spectrum_list[[NN]]=spectrum_list[[max_scan]]}

      # Calculate consensus spectra
      if (consensus & length(selected_rows)>1){ # If multiple spectra present we want to merge them
        splist = spectrum_list[index1[selected_rows]] # List of spectra with the same ID
        spectrum_averaged = average_spectrum(splist, ppm_window, clean = strict)
        new_spectrum_list[[NN]] = spectrum_averaged
      }}}


  #######################
  ### Consensus MS2 scan:
  #######################

  index2=which(metadata$MSLEVEL==2)
  if (length(index2)>0){
    metadata2=metadata[index2,]
    ID_list=unique(metadata2$ID)
    for (ID in ID_list){
      selected_rows = which(metadata2$ID==ID)
      tics = metadata$TIC[selected_rows]
      wm = which.max(tics)
      max_scan = index2[selected_rows[wm]] # Representative scan in the old library with the highest TIC

      new_meta_data = rbind.data.frame(new_meta_data,metadata[max_scan,]) # Update metadata
      NN = NN+1
      # Append spectra list if no need for spectra merge
      if (!consensus || length(selected_rows)==1){
        new_spectrum_list[[NN]]=spectrum_list[[max_scan]]}

      # Calculate consensus spectra
      if (consensus & length(selected_rows)>1){ # If multiple spectra present we want to merge them
        splist = spectrum_list[index2[selected_rows]] # List of spectra with the same ID
        spectrum_averaged = average_spectrum(splist, ppm_window, clean = strict)
        new_spectrum_list[[NN]] = spectrum_averaged
      }}}

  ####################
  ### Return results:
  ####################

  library = list()
  library$sp = new_spectrum_list
  library$metadata = new_meta_data

 # writeMGF2(library$sp,library$metadata,output_library)
  write.table(library$metadata,paste0(output_library,".txt"),col.names = T,row.names=F,dec=".",sep="\t")
  return(library)
}


###########################
### Internal functions:
###########################

Mgf2Splist<-function(MGFdat){

  # From a MSnBase object to a list of spectra m/z intensity
  N=length(MGFdat)
  spectrum_list=list()
  for (i in 1:N){spectrum_list[[i]]=cbind(MGFdat[[i]]@mz,MGFdat[[i]]@intensity)}
  return(spectrum_list)
}

writeMGF2 <- function(splist, metadata, con){
  .cat <- function(..., file = con, sep = "", append = TRUE) {
    cat(..., file = file, sep = sep, append = append)
  }

  con <- file(description = con, open = "at")
  on.exit(close(con))

  N=nrow(metadata)
  C=ncol(metadata)
  labels=colnames(metadata)
  for (i in 1:N) {
    .cat("\nBEGIN IONS\n")
    for (j in 1:C){
      .cat(labels[j],"=",metadata[i,j],"\n")}
    sp=splist[[i]]
    .cat(paste(sp[,1],"\t",sp[,2], collapse = "\n"))
    .cat("\nEND IONS\n")
  }
}
